
(define-syntax p-comprim
  (er-macro-transformer (lambda (exp rename compare)
    (let ((name (caadr exp))
          (formals (cdadr exp))
          (body (cddr exp)))
      `(hash-table-set! prim-compilers* (p-env-lookup toplevel-env ',name)
        (lambda (args senv)
          (apply (lambda ,formals ,@body) args)))))))

(define-predicate p-compiled?)
(define-operation (p-execute compiled env k err))
(define prim-compilers* (make-hash-table))

(define (compile exp senv) ; senv = static environment
  (cond ((p-cons? exp)
          (let ((operator (p-car exp)))
            (if (symbol? operator)
                  (let ((actualop (p-env-lookup senv operator)))
                    (cond ((p-macro? actualop)
                            (p-expand actualop (p-cdr exp) senv (lambda (expansion) (compile expansion senv)) top-error-handler))
                          ((and (p-prim? actualop) (hash-table-exists? prim-compilers* actualop))
                            (make-compiled (p-prim-compile (hash-table-ref prim-compilers* actualop) (p-cdr exp) senv)))
                          (else
                            (make-compiled (compile-application exp senv)))))
                  (make-compiled (compile-application exp senv)))))
        ((symbol? exp)
          (make-compiled (lambda (env k err)
            (let ((val (p-env-lookup env exp)))
              (if (eq? val no-binding*)
                    (err 'unbound-symbol (string-append "unbound symbol: " (symbol->string exp)))
                    (k val))))))
        (else (compile-to-eval exp))))

(define (compile-to-eval exp)
  (make-compiled
    (lambda (env k err)
      (p-eval exp env k err))))

(define (compile-application exp senv)
  (let* ((operator (compile (p-car exp) senv))
         (raw-args (p-cdr exp))
         (args (p-map (lambda (x) (compile x senv)) raw-args)))
    (lambda (env k err)
      (p-execute operator env (lambda (opex)
        (cond ((p-fn? opex)
                (p-execute-map args env (lambda (parms) (p-apply opex parms env k err)) err))
              ((p-prim? opex)
                (p-apply opex raw-args env k err))
              ((p-macro? opex)
                (p-expand opex raw-args env (lambda (new-exp)
                  (p-eval new-exp env k err)) err))
              ((p-continuation? opex)
                (p-execute (p-car (p-cdr args)) env (lambda (val) (p-invoke opex val)) err)))) err))))

(define (make-compiled proc)
  (p-obj
    ((p-execute exp env k err)
      (proc env k err))
    ((p-compiled? exp) #t)
    ((p-obj-type exp) 'compiled)))

(define (p-prim-compile compiler actuals senv)
  (compiler (plan->scheme-list actuals) senv))
(define (p-compile-seq seq senv)
  (make-compiled
    (if (null? (p-cdr seq))
          (let ((compiled (compile (p-car seq) senv)))
            (lambda (env k err)
              (p-execute compiled env k err)))
          (let ((compiled1 (compile (p-car seq) senv))
                (compiled-rest (p-compile-seq (p-cdr seq) senv)))
            (lambda (env k err)
              (p-execute compiled1 env (lambda (res) (p-execute compiled-rest env k err)) err))))))
